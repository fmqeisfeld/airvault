# connection properties
connection:
    host: 172.22.0.1 # gateway of pg-container
    db: dv2
    port: 5432
    user: postgres
    pw: postgres
    schemas:
      source: quelle
      stage: stage 
      edwh: edwh

rv:   # raw vault
  hubs:
    hub_tax_bundle:         # name der hub-tabelle
      hk: hk_tax_bundle     # benamung des hashkeys in zieltabelle
      bk: tax_bundle_id     # benamung des bks in der zieltabelle. Quasi die Klartext-version vom PK
      overwrite: False      # drop & recreate ? (tbd)

      src:                  # hub kann mehrere quellen haben                 
        v_report_taxation:  # erste quelle
          bkeycode: default # collision-code optional, defaults to 'default'
          tenant: default   # tenant-id, defaults to 'default'                  
          bks:              # namen der/des bk-felds in quelle          
            - tax_bundle_id # Bei Angabe mehrerer Quellfelder
            - dossier_uuid  # resultiert  ein Composite-Key, d.h. alle fliessen in selben Hash ein

        v_report_ziffer:    # 2te quelle
          bks: 
            - tax_bundle_id # name des bk-felds in quelle     
          

    hub_ziffer:
      hk: hk_ziffer
      bk: ziffer
      overwrite: False

      src:
        v_report_dict_ziffer:
          bks: 
            - ziffer
    
  links:
    lnk_taxbundle_ziffer:           # name der link-tabelle
      hk: hk_l_taxbundle_ziffer     # pk der link-tabelle
      hks:                          # hks der hubs
        - hk_ziffer
        - hk_tax_bundle
      overwrite: False

      cks:
        dossier_uuid: dossier       # child keys (geht nicht in hash rein, hat keine gehashte version und hat auch keinen zugeh. hub)
                                    # kann auch benutzt werden, wenn man nur aus gründen der wiederherstellbarkeit der quelle, ein attr. mitschelleppen will
                                    # "don't split unit of work"
                                    # falls eine der quellen nicht über dieses Feld verfügt, wird hierfür zerokey (=-1) eingesetzt

      src:                          # link kann mehrere quellen haben
        v_report_ziffer:            # erste quelle
          bkeycode: default         # optionaler collision code (geht ein in hash, defaults to 'default')
          tenant: default           # optional für multi-tenancy (geht in hash rein, defaults to 'default')
          bks:                      # link verknüpft mehrere hubs -> mindestens 2 bks pro quelle nötig. Reihenfolge wichtig für hashing
            ziffer: hk_ziffer       # bk aus quelle (des zugeh. hubs) und name des gehashten keys in link-tabelle
            tax_bundle_id: hk_tax_bundle 
            snapshot_version: hk_tax_bundle # beispiel für composite-key: verschiedene quell-felder mappen zum selben hk

        v_report_taxation:       # 2te quelle     
          bks:                   
            ziffer: hk_ziffer    # quelle enthält keinen bk "ziffer". Hier wird automatisch zero-key ("-1") verwendet
            tax_bundle_id: hk_tax_bundle 

  sats:
    sat_taxbundle:
        hk: hk_tax_bundle
        #cks:
        #  dossier_uuid: dossier
        #multiactive: true     # defaults to 'false' 
        attrs:                # benamung der attribute in der ziel-tabelle
          - taxation_type
          - status
          - gemeinde_bfs
        src:
          v_report_taxation:
            bks:
              - tax_bundle_id
              - snapshot_version
            attrs:            # mapping der attributnamen quelltabelle -> zieltabelle
              taxation_type: taxation_type
              status: status
              gemeinde_bfs: gemeinde_bfs


    